---
description: Testing strategies, patterns, and tools for Cloudflare Workers with Vitest
globs: ["**/*.test.ts", "**/*.spec.ts", "vitest.config.*", "apps/**/src/**/*.ts"]
alwaysApply: false
---

# Testing Patterns and Practices

This guide covers testing strategies, patterns, and tools used across the Workers monorepo.

## Testing Stack

### Core Testing Tools

- **[Vitest](https://vitest.dev/)** - Fast unit testing framework
- **[@cloudflare/vitest-pool-workers](https://github.com/cloudflare/workers-sdk/tree/main/packages/vitest-pool-workers)** - Worker runtime testing
- **[Cloudflare Test Environment](https://developers.cloudflare.com/workers/testing/)** - Integration testing utilities

### Configuration

- **Root**: [vitest.config.ts](mdc:vitest.config.ts) - Workspace test configuration with separate projects for workers and packages
- **Workers**: Use `@cloudflare/vitest-pool-workers` for Workers runtime testing
- **Packages**: Use Node.js environment for package tests

## Testing Strategy Framework

### Unit Testing
- Pure function testing with Vitest
- Isolated component testing
- Mock strategy for external dependencies
- Edge case and boundary testing
- Performance unit testing

### Integration Testing
- Database integration with test databases
- API endpoint testing with real bindings
- Authentication flow testing with Better Auth
- Cross-package integration testing
- External service integration testing
- Binding integration testing (KV, R2, D1, Hyperdrive)

### End-to-End Testing
- Complete user journey testing
- Multi-worker coordination testing
- Geographic distribution testing
- Load and stress testing
- Disaster recovery testing

### Contract Testing
- API contract validation
- Database schema contract testing
- Inter-service communication contracts
- External dependency contracts
- Version compatibility testing

## Cloudflare Workers Testing Focus

### Edge Computing Testing Challenges
- Multi-region deployment testing
- Cold start behavior validation
- Geographic latency considerations
- Distributed state management testing
- Edge cache behavior validation

### Workers Runtime Testing
- V8 isolate behavior testing
- Memory and CPU constraint testing
- Concurrent request handling
- Resource cleanup validation
- Error boundary testing

## Test Structure

### Worker Testing Pattern

```
apps/example-worker/
└── src/
    ├── index.ts
    ├── test/
    │   └── index.test.ts      # Tests in dedicated test directory
    └── services/
        ├── user-service.ts
        └── ...
```

### Package Testing Pattern

```
packages/middleware/
└── src/
    ├── index.ts
    ├── cors.ts
    ├── test/
    │   └── index.test.ts     # Tests in dedicated test directory
    └── ...
```

Tests are placed in a dedicated `test/` directory within `src/` with `.test.ts` extension.

## Worker Integration Tests

### Basic Worker Test

```typescript
// apps/example-worker/src/test/index.test.ts
import { createExecutionContext, env, waitOnExecutionContext } from 'cloudflare:test'
import { describe, expect, it } from 'vitest'

import worker from '../index'

describe('Example Worker', () => {
	it('handles GET request', async () => {
		const request = new Request('http://example.com/', {
			method: 'GET',
		})
		const ctx = createExecutionContext()

		const response = await worker.fetch(request, env, ctx)
		await waitOnExecutionContext(ctx)

		expect(response.status).toBe(200)
		const data = await response.json()
		expect(data.success).toBe(true)
	})

	it('handles POST request with JSON', async () => {
		const request = new Request('http://example.com/api/users', {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({ email: 'test@example.com' }),
		})
		const ctx = createExecutionContext()

		const response = await worker.fetch(request, env, ctx)
		await waitOnExecutionContext(ctx)

		expect(response.status).toBe(200)
		const data = await response.json()
		expect(data.success).toBe(true)
	})
})
```

### Testing with Environment Variables

```typescript
// Mock environment variables
describe('Worker with Environment', () => {
	it('uses environment variables', async () => {
		// env object is automatically populated from .dev.vars
		expect(env.SOME_SECRET).toBeDefined()

		const request = new Request('http://example.com/config')
		const ctx = createExecutionContext()
		const response = await worker.fetch(request, env, ctx)

		expect(response.status).toBe(200)
	})
})
```

### Database Testing

```typescript
// Database testing with transactions
import { createDb } from '@repo/db'

describe('Database Operations', () => {
	it('uses database connection', async () => {
		// env is available from cloudflare:test
		// DATABASE_URL or HYPERDRIVE binding is loaded from .dev.vars
		const db = createDb(env)
		const users = await db.select().from(usersTable)
		expect(users).toBeDefined()
	})

	it('handles database transactions', async () => {
		const db = createDb(env)
		await db.transaction(async (tx) => {
			// Setup test data
			// Test operations
			// Rollback automatically on error
		})
	})
})
```

### Authentication Testing

```typescript
// Better Auth testing patterns
import { createAuth } from '@repo/auth'

describe('Authentication', () => {
	it('should authenticate valid users', async () => {
		const auth = createAuth(env)
		const { session } = await auth.api.signInEmail({
			email: 'test@example.com',
			password: 'password',
		})
		expect(session).toBeDefined()
	})
})
```

### Test Worker Bindings

```typescript
it('uses rate limiter binding', async () => {
	if (env.RATE_LIMITER) {
		const result = await env.RATE_LIMITER.limit({
			key: 'test-key',
			limit: 10,
			window: 60,
		})
		expect(result.success).toBeDefined()
	}
})
```

## Unit Testing Shared Packages

### Testing Middleware

```typescript
// packages/middleware/src/test/cors.test.ts
import { Hono } from 'hono'
import { describe, expect, it } from 'vitest'

import { enhancedCors } from '../cors'

describe('CORS Middleware', () => {
	it('applies CORS headers', async () => {
		const app = new Hono()
		app.use('*', enhancedCors({ environment: 'development' }))
		app.get('/', (c) => c.text('OK'))

		const request = new Request('http://localhost/')
		const response = await app.request(request)

		expect(response.headers.get('Access-Control-Allow-Origin')).toBeDefined()
	})

	it('handles preflight requests', async () => {
		const app = new Hono()
		app.use('*', enhancedCors({ environment: 'development' }))
		app.options('*', (c) => c.text(''))

		const request = new Request('http://localhost/', { method: 'OPTIONS' })
		const response = await app.request(request)

		expect(response.status).toBe(200)
	})
})
```

### Testing TypeScript Types

```typescript
// packages/package-name/src/test/types.test.ts
import { describe, expectTypeOf, it } from 'vitest'

import type { SomeFunction, SomeType } from '../types'

describe('Type Tests', () => {
	it('has correct type signature', () => {
		expectTypeOf<SomeFunction>().toEqualTypeOf<(input: string) => number>()
	})

	it('exports expected types', () => {
		expectTypeOf<SomeType>().toHaveProperty('id')
		expectTypeOf<SomeType>().toHaveProperty('name')
	})
})
```

### Hono App Testing

```typescript
import { describe, it, expect } from 'vitest'
import app from './index'

describe('API', () => {
	it('should return hello', async () => {
		const res = await app.request('/')
		expect(res.status).toBe(200)
		expect(await res.text()).toBe('Hello!')
	})

	it('should create user', async () => {
		const res = await app.request('/users', {
			method: 'POST',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({ email: 'test@example.com', name: 'Test' }),
		})
		expect(res.status).toBe(201)
	})
})
```

## Test Commands

### Running Tests

```bash
# Run all tests
just test
# or
pnpm test

# Run tests in watch mode
just test-watch
# or
pnpm test:watch

# Run tests with coverage
just test-coverage
# or
pnpm test:coverage

# Run tests for specific package
pnpm --filter @repo/middleware test

# Run tests for specific worker
pnpm --filter example-worker test

# Watch mode for development
pnpm test:watch
```

### Turbo Test Pipeline

```bash
# Run tests with dependency awareness
pnpm turbo test

# Tests run in parallel where possible
# Workers use Workers pool, packages use Node.js environment
```

## Vitest Configuration

### Workspace Configuration

[vitest.config.ts](mdc:vitest.config.ts) defines separate projects:

```typescript
import { defineWorkersConfig } from "@cloudflare/vitest-pool-workers/config"
import { defineConfig } from "vitest/config"

export default defineConfig({
	test: {
		projects: [
			// Workers tests - use Workers pool
			defineWorkersConfig({
				test: {
					name: "workers",
					include: ["apps/**/*.{test,spec}.{js,ts,tsx}"],
					poolOptions: {
						workers: {
							wrangler: { configPath: "./apps/example-worker/wrangler.jsonc" },
							miniflare: {
								compatibilityDate: "2025-09-21",
								compatibilityFlags: ["nodejs_compat"],
							},
						},
					},
				},
			}),
			// Package tests - use Node.js environment
			{
				test: {
					name: "packages",
					include: ["packages/**/*.{test,spec}.{js,ts,tsx}"],
					environment: "node",
				},
			},
		],
	},
})
```

### Test Structure

- **Workers**: Tests use `@cloudflare/vitest-pool-workers` for Workers runtime
- **Packages**: Tests use Node.js environment
- **Location**: Tests placed in `src/test/` directory with `.test.ts` extension
- **Coverage**: Configured with v8 provider, excludes node_modules, dist, .wrangler

## Testing Best Practices

### 1. Test Structure

- **Tests in dedicated directories**: All tests in `src/test/` directory
- **Workers**: Test files in `apps/*/src/test/` directory
- **Packages**: Test files in `packages/*/src/test/` directory
- **Consistent naming**: `*.test.ts` or `*.spec.ts` pattern
- **Import paths**: Use relative imports from test directory (e.g., `import worker from "../index"`)

### 2. Environment Setup

- Use `.dev.vars` files for test environment variables (automatically loaded by Workers pool)
- Mock external services appropriately using Vitest mocks
- Test both success and error cases
- Use `@repo/testing` package for shared test utilities and fixtures
- Place all test files in `src/test/` directory structure

### 3. Coverage and Quality

```bash
# Run tests with coverage
pnpm test --coverage

# Type check tests
pnpm turbo check:types
```

### 4. CI Integration

Tests run automatically in CI:

- **Branch workflow** - All PRs and feature branches (via `pnpm test`)
- **Release workflow** - Before deployment to production (via `pnpm test`)
- Tests run in parallel where possible using Vitest projects

### 5. Debugging Tests

```bash
# Debug specific test
pnpm --filter example-worker test -- --reporter=verbose test/index.test.ts

# Run with debug output
DEBUG=* pnpm test

# Run single test file
pnpm test apps/example-worker/src/test/index.test.ts
```

## Common Testing Patterns

### Mock External APIs

```typescript
// Mock fetch for external API calls
global.fetch = vi.fn().mockResolvedValue({
	ok: true,
	json: () => Promise.resolve({ data: 'mocked' }),
})
```

### Test Error Handling

```typescript
it('handles errors gracefully', async () => {
	const request = new Request('http://example.com/error')
	const ctx = createExecutionContext()

	const response = await worker.fetch(request, env, ctx)

	expect(response.status).toBe(500)
	expect(await response.text()).toContain('Error')
})
```

## Test Data Management

### Test Data Strategies
- Factory pattern for test data creation
- Database seeding for consistent tests
- Synthetic data generation
- Test data isolation strategies
- Test data cleanup automation

### Mock and Stub Strategies
- External API mocking
- Database operation stubbing
- Authentication service mocking
- Time and date mocking
- Network condition simulation

## Performance Testing

### Load Testing
- Concurrent request testing
- Geographic load distribution
- Database connection pool testing
- Memory usage under load
- CPU utilization testing

### Stress Testing
- Resource exhaustion testing
- Connection limit testing
- Memory leak detection
- Error rate under stress
- Recovery testing

### Benchmarking
- Performance regression testing
- Bundle size impact testing
- Cold start performance
- Database query performance
- Network latency testing

## Testing Environments

### Local Development Testing
- Wrangler dev environment testing
- Local database testing with Docker
- Mock external services
- Environment variable testing
- Hot reload testing validation

### Staging Environment Testing
- Production-like environment testing
- Real binding integration testing
- Performance baseline testing
- Security testing in staging
- Migration testing validation

### Production Testing
- Health check monitoring
- Smoke testing after deployments
- Performance monitoring
- Error rate monitoring
- Geographic performance testing

## Specialized Testing Areas

### Security Testing
- Authentication bypass testing
- Authorization testing
- Input validation testing
- SQL injection testing
- XSS vulnerability testing

### Compatibility Testing
- Browser compatibility testing
- Mobile device testing
- Network condition testing
- Regional compliance testing
- Accessibility testing

### Migration Testing
- Database migration testing
- Code deployment testing
- Configuration change testing
- Rollback procedure testing
- Data integrity testing

## Testing Tools Integration

### External Tools
- Playwright for E2E testing
- Artillery for load testing
- Lighthouse for performance testing
- OWASP ZAP for security testing
- Database testing tools integration

## Test Monitoring and Reporting

### Test Metrics
- Test execution time tracking
- Test success/failure rates
- Coverage trend analysis
- Performance test results
- Flaky test identification

### Reporting and Analytics
- Test result dashboards
- Performance trend reports
- Test coverage reports
- Quality metrics tracking
- Testing ROI analysis
