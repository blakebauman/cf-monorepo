---
description: Testing strategies and patterns for Cloudflare Workers applications
globs: ["**/*.test.ts", "**/*.spec.ts", "vitest.config.*", "apps/**/src/**/*.ts"]
---

# Testing Guidelines

Comprehensive testing strategies for Cloudflare Workers applications and distributed edge computing systems.

## Testing Strategy Framework

### Unit Testing
- Pure function testing with Vitest
- Isolated component testing
- Mock strategy for external dependencies
- Edge case and boundary testing
- Performance unit testing

### Integration Testing
- Database integration with test databases
- API endpoint testing with real bindings
- Authentication flow testing
- Cross-package integration testing
- External service integration testing

### End-to-End Testing
- Complete user journey testing
- Multi-worker coordination testing
- Geographic distribution testing
- Load and stress testing
- Disaster recovery testing

### Contract Testing
- API contract validation
- Database schema contract testing
- Inter-service communication contracts
- External dependency contracts
- Version compatibility testing

## Cloudflare Workers Testing Focus

### Edge Computing Testing Challenges
- Multi-region deployment testing
- Cold start behavior validation
- Geographic latency considerations
- Distributed state management testing
- Edge cache behavior validation

### Workers Runtime Testing
- V8 isolate behavior testing
- Memory and CPU constraint testing
- Concurrent request handling
- Resource cleanup validation
- Error boundary testing

### Integration Testing Complexity
- Database connection testing with Hyperdrive
- External API integration testing
- Authentication flow testing with Better Auth
- Cross-service communication testing
- Binding integration testing (KV, R2, D1)

## Testing Patterns for Workers

### Worker Test Structure
```typescript
// src/worker.test.ts
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { unstable_dev } from "wrangler";
import type { UnstableDevWorker } from "wrangler";

describe("Worker Tests", () => {
	let worker: UnstableDevWorker;

	beforeEach(async () => {
		worker = await unstable_dev("src/index.ts", {
			experimental: { disableExperimentalWarning: true },
		});
	});

	afterEach(async () => {
		await worker.stop();
	});

	it("should handle requests correctly", async () => {
		const resp = await worker.fetch("/api/test");
		expect(resp.status).toBe(200);
	});
});
```

### Database Testing
```typescript
// Database testing with transactions
import { createDb } from "@cf-monorepo/db";

describe("Database Operations", () => {
	let db: ReturnType<typeof createDb>;

	beforeEach(async () => {
		// Use test database
		db = createDb(testEnv);
		await db.transaction(async (tx) => {
			// Setup test data
		});
	});

	afterEach(async () => {
		// Cleanup test data
		await cleanupTestDb(db);
	});
});
```

### Authentication Testing
```typescript
// Better Auth testing patterns
import { createAuth } from "@cf-monorepo/auth";

describe("Authentication", () => {
	it("should authenticate valid users", async () => {
		const auth = createAuth(testEnv);
		const { session } = await auth.api.signInEmail({
			email: "test@example.com",
			password: "password",
		});
		expect(session).toBeDefined();
	});
});
```

### Hono App Testing
```typescript
import { describe, it, expect } from "vitest";
import app from "./index";

describe("API", () => {
	it("should return hello", async () => {
		const res = await app.request("/");
		expect(res.status).toBe(200);
		expect(await res.text()).toBe("Hello!");
	});

	it("should create user", async () => {
		const res = await app.request("/users", {
			method: "POST",
			headers: { "Content-Type": "application/json" },
			body: JSON.stringify({ email: "test@example.com", name: "Test" }),
		});
		expect(res.status).toBe(201);
	});
});
```

## Testing Environment Setup

### Local Development Testing
- Wrangler dev environment testing
- Local database testing with Docker
- Mock external services
- Environment variable testing
- Hot reload testing validation

### Staging Environment Testing
- Production-like environment testing
- Real binding integration testing
- Performance baseline testing
- Security testing in staging
- Migration testing validation

### Production Testing
- Health check monitoring
- Smoke testing after deployments
- Performance monitoring
- Error rate monitoring
- Geographic performance testing

## Test Data Management

### Test Data Strategies
- Factory pattern for test data creation
- Database seeding for consistent tests
- Synthetic data generation
- Test data isolation strategies
- Test data cleanup automation

### Mock and Stub Strategies
- External API mocking
- Database operation stubbing
- Authentication service mocking
- Time and date mocking
- Network condition simulation

## Performance Testing

### Load Testing
- Concurrent request testing
- Geographic load distribution
- Database connection pool testing
- Memory usage under load
- CPU utilization testing

### Stress Testing
- Resource exhaustion testing
- Connection limit testing
- Memory leak detection
- Error rate under stress
- Recovery testing

### Benchmarking
- Performance regression testing
- Bundle size impact testing
- Cold start performance
- Database query performance
- Network latency testing

## Testing Automation

### CI/CD Integration
```yaml
# Testing pipeline example
test:
	runs-on: ubuntu-latest
	steps:
		- name: Run Unit Tests
			run: pnpm test

		- name: Run Integration Tests
			run: pnpm test:integration

		- name: Run E2E Tests
			run: pnpm test:e2e

		- name: Performance Tests
			run: pnpm test:performance
```

### Test Coverage
- Code coverage requirements
- Integration coverage metrics
- End-to-end coverage validation
- Performance coverage tracking
- Security test coverage

## Testing Best Practices

### Test Organization
- Test file organization and naming (`*.test.ts` or `*.spec.ts`)
- Test suite structuring
- Shared test utilities
- Test configuration management
- Test environment separation

### Test Quality
- Test readability and maintainability
- Test isolation and independence
- Test data management
- Test execution speed optimization
- Test flakiness prevention

### Edge Case Testing
- Network failure scenarios
- Database connection failures
- Resource constraint scenarios
- Concurrent access patterns
- Geographic edge cases

## Specialized Testing Areas

### Security Testing
- Authentication bypass testing
- Authorization testing
- Input validation testing
- SQL injection testing
- XSS vulnerability testing

### Compatibility Testing
- Browser compatibility testing
- Mobile device testing
- Network condition testing
- Regional compliance testing
- Accessibility testing

### Migration Testing
- Database migration testing
- Code deployment testing
- Configuration change testing
- Rollback procedure testing
- Data integrity testing

## Testing Tools Integration

### Vitest Configuration
- Optimal Vitest setup for Workers
- Workers pool configuration
- Custom test environment setup
- Performance testing integration
- Coverage reporting setup

### External Tools
- Playwright for E2E testing
- Artillery for load testing
- Lighthouse for performance testing
- OWASP ZAP for security testing
- Database testing tools integration

## Test Monitoring and Reporting

### Test Metrics
- Test execution time tracking
- Test success/failure rates
- Coverage trend analysis
- Performance test results
- Flaky test identification

### Reporting and Analytics
- Test result dashboards
- Performance trend reports
- Test coverage reports
- Quality metrics tracking
- Testing ROI analysis
